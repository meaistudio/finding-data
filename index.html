<!DOCTYPE html>
<!-- saved from url=(0049)file:///D:/.DIVABHAWANA/INTERNET%20ART/MOUSE.html -->
<html lang="id"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Finding Data</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        font-family: 'Courier New', Courier, monospace;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="canvas" width="2552" height="1308"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let mouseX = 0;
let mouseY = 0;
let blocks = [];

const circleRadius = 80;
let schemeIndex = 0;

const cmykColors = ["cyan", "magenta", "yellow", "black"];

// ==== SKEMA WARNA GLOBAL ====
const schemes = [
    { bg: "black", text: "cyan", block: "magenta" },
    { bg: "cyan", text: "black", block: "yellow" },
    { bg: "magenta", text: "yellow", block: "black" },
    { bg: "yellow", text: "cyan", block: "black" }
];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    buildGrid();
}
window.addEventListener("resize", resize);

window.addEventListener("mousemove", (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

window.addEventListener("click", () => {
    schemeIndex = (schemeIndex + 1) % schemes.length;
});

// Collision detection
function circleRectCollision(cx, cy, radius, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.height));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < radius * radius;
}

function buildGrid() {
    ctx.font = "24px monospace";

    const sampleText = `(0000,0000)(0000,0000)(0000,0000)(0000,0000)   (0000,0000)`;
    const textWidth = ctx.measureText(sampleText).width;
    const textHeight = 24;

    const spacingX = textWidth + 20;
    const spacingY = textHeight + 1;

    blocks = [];

    for (let y = spacingY; y < canvas.height; y += spacingY) {
        for (let x = 0; x < canvas.width; x += spacingX) {

            blocks.push({
                x: x,
                y: y - textHeight,
                width: textWidth,
                height: textHeight,
                highlight: 0,
                glitchTimer: 0
            });
        }
    }
}

function updateAndDrawBlocks() {
    const scheme = schemes[schemeIndex];

    blocks.forEach(block => {

        const hit = circleRectCollision(mouseX, mouseY, circleRadius, block);

        if (hit) {
            block.highlight = 1;
            block.glitchTimer = 0;
        } else {
            if (block.highlight > 1) {
                block.highlight *= 0.99; // delay fade
            } else if (block.highlight > 0) {
                block.highlight = 0;
                block.glitchTimer = 100; // glitch setelah delay
            }
        }

        // === WARNA BLOCK ===
        let blockColor = scheme.block;

        if (block.glitchTimer > 0) {
            blockColor = cmykColors[Math.floor(Math.random() * 6)];
            block.glitchTimer--;
        }

        // block highlight
        if (block.highlight > 0 || block.glitchTimer > 0) {
            ctx.fillStyle = blockColor;
            ctx.globalAlpha = block.highlight > 0 ? block.highlight : 1;
            ctx.fillRect(block.x - 0, block.y - 0, block.width + 1, block.height + 2);
            ctx.globalAlpha = 1;
        }

        // text tetap normal
        const x1 = Math.floor(mouseX);
        const x2 = x1 + 10;
        const x3 = x1 + 20;
        const x4 = x1 + 30;
        const x5 = x1 + 40;

        const text = `(${x1},${mouseY}) (${x2},${mouseY}) (${x3},${mouseY}) (${x4},${mouseY}) (${x5},${mouseY})`;

        ctx.fillStyle = scheme.text;
        ctx.fillText(text, block.x, block.y + block.height);
    });
}

function drawCursorCircle() {
    ctx.strokeStyle = schemes[schemeIndex].text;
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, circleRadius, 0, Math.PI * 2);
    ctx.stroke();
}

function animate() {
    const scheme = schemes[schemeIndex];

    ctx.fillStyle = scheme.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    updateAndDrawBlocks();
    drawCursorCircle();

    requestAnimationFrame(animate);
}

resize();
animate();
</script>


</body></html>